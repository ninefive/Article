# 聊一聊电商的营销系统插件化

营销系统，简单的说就是打拆，举个例子，满300减20，达到条件，你就可以少给20块。听上去蛮简单的，但在具体的计算上却并没有那么的简单。比如，多商品，多条件，不同的营销规则又有不同的适用范围等等。

就本身来讲，利用商品的价格结合买家自身的数据，要计算出折扣结果，并没多大的困难，也就比增删改查复杂了那么一点，但那是一段程序，它解决的也就是当前产品或运营提出的一些需求。试想一下，如果 某天要增加另外的营销规则，我们要以什么样的方式把它们加到系统里呢？以后要继续增加呢？

在我做金箍棒海淘的时候，就需到了这样的问题，当运营提出需要新的规则时，我们对这一部分的计算进行了调整，新需求出来时，我们又要去这一部分进行调整，以至于这一部分的计算不够稳定，代码也不易维护，要花更多的时间去测试和解决bug。也许你会说，那是你们能力不够。这也是有个原因吧，但如果你自己先试试会更有说服力一些。所以呢，这里的问题就是：规则的多样性和多变性，会让程序变得不稳定和维护困难。

到微猫后，我提出了营销插件的思路，但在java里并没有得到有效的实施。做新的b2c saas时，仍然没能完全执行，虽然有点影子。借着这次API标准化的机会，我自己实现了它，于是就有这了这篇东西，希望能得到一些建议。

好了，先来看张图：

![image](https://github.com/Yuiitsu/Blog/blob/master/static/images/other/01.png)

看了这图，先有两个说明：

1.规则适用范围：如，所有商品适用，某些分类适用或指定商品适用等。

2.规则 使用条件：如满多少减多少，满多少包邮等

这些都是一个营销规则的属性，它们组成一条营销规则，所以，建立一个营销活动，就是来组合这些属性，并且可以多个组合，这点很重要。

## 图中的营销活动：

这一部分就是使用适用范围和使用条件来组合成一条营销活动，后台的管理功能就是来做这事儿的。当然，还有其它的属性，如名字，有效时间等，但这些和计算并没有直接的关系。

## 图中的营销管理器：

它是整个营销计算的路由，当然系统有三层路由，这是第一层。系统在调用营销计算时，就是调用它，它做三件事：

1.获取当前所有有正在进行中的活动

2.根据活动设置的适用范围调用对应适用范围包来计算商品是否在适用范围内，在将其返回

3.根据活动设置的使用条件调用对应的使用条件包，将前面返回的适用商品传给它，让它计算是否满足使用条件，如果满足计算折扣

4.返回可以使用的营销活动

## 图中的营销插件管理器：

营销插件被调用后，根据传递的参数，调用对应的适用范围包，计算后得到可用的对象，再使用这些商品去调用对应的适用条件进行金额计算，并返回折扣金额。营销插件得到这些数据后，自行判断是否要均摊费用。

可以看到，每个计算点都是一个独立的包，它们相互独立，互不影响，靠上一级的管理器根据活动的设置进行调用。如果要增加营销规则，只要建立一个对应的包，系统就会根据包名去调用它计算结果，再返给上一级。新的营销插件也是同理。

## 相互影响的点：

营销规则的顺序。有的营销规则要求它的计算需要前一个规则 的计算结果 ，举个例子：优惠券的使用条件需要在满减之后的结果上进行，如：优惠券满100关系10元，同时还有一个满减活动，满100减5元。那么满减活动生效后，实际金额就变成了95块，不再满足优惠券的使用条件，那优惠券就不能再使用了。

那么，顺序就是一个问题，如果按流程的写法，只要按固定顺序去写就可以了，但按插件的方式，很有可能计算的顺序不是你想要的，所以我们要确定这个顺序，但这个顺序不能直接在程序里去确定，那样的结果就是以后要增加一个顺序，就要改程序啦，不满足我们的设计目标。

所以，在这里，我使用了26个字母来给营销插件做首字母，那么，按ASCII码来排序。如：满减我们用cut，那优惠券就用m_coupon，首字母c和m的顺序刚好，自然优惠券就排到了满减的后面。26个字母可以支持26个营销插件的排序，要更多就用第一个字母做排序，这样成倍的增加了顺序位置，肯定能满足需求了。

## 关键点：

上面已经说了，所有的处理点都在各自的包里，利用包名进行调用，这就是一个解耦的过程，只用关系参数和返回数据，不用关心是怎么计算的。

## 难点：

有些数据，并不是想解耦就能解，如运费的减免不算入下一个营销规则的使用条件里。按插件包的概念，单独计算并不能很好的实现，只能返回到上一级包里去进行，那势必会在上一级包里出现如：if shipping_fee这样的代码，解耦就失败了，以后要是有新的这样的费用计算，都要到这一层处理，那也就和之前的做法没啥区别了。

很遗憾，我还没有想到更好的处理方法，这一部分只能先由上级包来统一处理。

好啦，就这么多了，这种方式的好处显而易见。但设计实现时难度比直接以流程的试写困难，但这些困难都是值得的，当所有的管理器都正常工作后，我们只用关心各个处理规则的包的实现就行了，相互的影响极小，修改，增加新规则影响到其它规则和系统的可能性就小了很多，整个系统会更加的稳定和易于维护。