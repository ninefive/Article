# 再谈贪食蛇

记得《爱情公寓》里有句很牛B的话，叫：写得最好的一条代码，永远是下一条。表面看是吹牛B，实际是很好的方法。不时的重新思考一下以前写过的东西，总是能有更好的思路。

最近借着学习Android的机会，在Android上重写了一下去年用JS写过的小游戏贪食蛇，就如前面所说，得到了一些新的东西，所以打算再写一篇加以说明。

贪食蛇本身来讲是一个很简单的游戏，其唯一的一个难点仅仅是在移动转向上。在去年的写的代码里，我使用了一个转角判断的方法，每次按下方向键，会用一个数组记录下这个点的坐标和转向，蛇身上的点在经过这些转角点的时候都要根据转角点的方向来改变方向。直到所有蛇身都经过这个转角点，才把它的信息从数组中删除。

**这个过程可以看做是队列的处理，先进先出**

![image](https://github.com/onlyfu/Blog/raw/master/static/images/android/20151122/01.jpg)

```
// 转角数组
[
	{10, 15, "E"},
	{10, 17, "N"}
]
```

这样处理的方式没有错，也能实现转向的目的，但仔细思考后你会发现，蛇本身来讲就是一个链表的结构，那为什么还要用别的队列来处理它呢？蛇身的移动，可以看做是补位的操作，除蛇头外，其余的蛇身总是移动到它前一个蛇身的上一个位置上，不管怎么转方向，这个过程都是不变的。那么，我们只要让除蛇尾的每一个蛇身都记住它前一个位置的坐标，就能够满足这样的需求。看看是不是一个简单的鍡结构：

![image](https://github.com/onlyfu/Blog/raw/master/static/images/android/20151122/02.jpg)

所以，如果把蛇身看做一个对象，它就可以拥有前一位置的横纵坐标和当前位置的横纵坐标的属性，当移动开始时，每次移动都更新自己的两组坐标值，而后一蛇身在移动时，先获取前一蛇身的前一位置坐标，再把它当做自己的妆前位置坐标即可。

简单的游戏，就是简单的结构，复杂的游戏就是很多简单的游戏结构组合而成。这样一来，程序也不用去判断转角的创建与清除，相对来说，更清晰一些。

好了，贪食蛇就是这样了。
